{"version":3,"file":"index.mjs","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/EventEmitter.ts","../src/Figure/FreeLine.ts","../src/Figure/StraightLine.ts","../src/Figure/Rectangle.ts","../src/Figure/Ellipse.ts","../src/Figure/Arrow.ts","../src/Painter.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","export type Listener = (...args: any) => void;\nexport default class EventEmitter {\n  private _events: { [event: string]: Listener[] };\n\n  constructor() {\n      this._events = {};\n  }\n\n  emit(event: string, ...args: any) {\n      for (const fn of this._events[event] || []) {\n          fn(...args);\n      }\n  }\n\n  on(event: string, callback: Listener) {\n      (this._events[event] = this._events[event] || []).push(callback);\n\n      return () =>\n          (this._events[event] = this._events[event].filter(\n              (fn) => fn !== callback\n          ));\n  }\n\n  allOff() {\n      this._events = {};\n  }\n}\n","import { Figure, FigureData, DrawingEventSource } from '../types';\n\nexport default class FreeLine implements Figure {\n    constructor(\n        private _data: FigureData\n    ) {}\n\n    get data() {\n        return this._data;\n    }\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { color, thickness, lineCap } = this._data.drawOption;\n        const { width, height } = ctx.canvas;\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        ctx.beginPath();\n\n        for await (const event of events) {\n            const { x, y } = event.relativePosition;\n\n            if (this._data.positions.length) {\n                ctx.lineTo(width * x, height * y);\n                ctx.stroke();\n            } else {\n                ctx.moveTo(width * x, height * y);\n            }\n\n            this._data.positions.push({ x, y });\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        if (!this._data.positions.length) return;\n\n        const { color, thickness, lineCap } = this._data.drawOption;\n        const { width, height } = ctx.canvas;\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        ctx.beginPath();\n\n        for (const position of this._data.positions) {\n            ctx.lineTo(width * position.x, height * position.y);\n            ctx.stroke();\n        }\n    }\n}\n","import { Figure, FigureData, DrawingEventSource } from '../types';\n\nexport default class StraightLine implements Figure {\n    constructor(\n        private _data: FigureData\n    ) {}\n\n    get data() {\n        return this._data;\n    }\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { width, height } = ctx.canvas;\n\n        for await (const event of events) {\n            const { relativePosition } = event;\n            this._data.positions.push(relativePosition);\n            ctx.clearRect(0, 0, width, height);\n            this.render(ctx);\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        const { drawOption: { color, thickness, lineCap }, positions } = this._data;\n        if (positions.length < 2) return;\n\n        const { width, height } = ctx.canvas;\n        const { x: startX, y: startY } = positions[0];\n        const { x, y } = positions[positions.length - 1];\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        ctx.beginPath();\n        ctx.moveTo(startX * width, startY * height);\n        ctx.lineTo(x * width, y * height);\n        ctx.stroke();\n    }\n}\n","import { Figure, FigureData, DrawingEventSource } from '../types';\n\nexport default class Rectangle implements Figure {\n    constructor(\n        private _data: FigureData\n    ) {}\n\n    get data() {\n        return this._data;\n    }\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { width, height } = ctx.canvas;\n\n        for await (const event of events) {\n            const { relativePosition } = event;\n            this._data.positions.push(relativePosition);\n            ctx.clearRect(0, 0, width, height);\n            this.render(ctx);\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        const { drawOption: { color, thickness, lineCap }, positions } = this._data;\n        if (positions.length < 2) return;\n\n        const { width, height } = ctx.canvas;\n        const { x: startX, y: startY } = positions[0];\n        const { x, y } = positions[positions.length - 1];\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        ctx.strokeRect(\n            startX * width,\n            startY * height,\n            (x - startX) * width,\n            (y - startY) * height\n        );\n    }\n}\n","import { Figure, FigureData, DrawingEventSource } from '../types';\n\nexport default class Ellipse implements Figure {\n    constructor(private _data: FigureData) {}\n\n    get data() {\n        return this._data;\n    }\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { width, height } = ctx.canvas;\n\n        for await (const event of events) {\n            const { relativePosition } = event;\n            this._data.positions.push(relativePosition);\n            ctx.clearRect(0, 0, width, height);\n            this.render(ctx);\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        const {\n            drawOption: { color, thickness, lineCap },\n            positions,\n        } = this._data;\n        if (positions.length < 2) return;\n\n        const { canvas } = ctx;\n        const start = positions[0];\n        const end = positions[positions.length - 1];\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        ctx.beginPath();\n\n        const startX = start.x * canvas.width;\n        const startY = start.y * canvas.height;\n        const x = end.x * canvas.width;\n        const y = end.y * canvas.height;\n        const width = x - startX;\n        const height = y - startY;\n        const kappa = (4 * (Math.sqrt(2) - 1)) / 3;\n        const offsetX = (width / 2) * kappa;\n        const offsetY = (height / 2) * kappa;\n        const endX = startX + width;\n        const endY = startY + height;\n        const midX = startX + width / 2;\n        const midY = startY + height / 2;\n\n        ctx.beginPath();\n        ctx.moveTo(startX, midY);\n        ctx.bezierCurveTo(\n            startX,\n            midY - offsetY,\n            midX - offsetX,\n            startY,\n            midX,\n            startY\n        );\n        ctx.bezierCurveTo(midX + offsetX, startY, endX, midY - offsetY, endX, midY);\n        ctx.bezierCurveTo(endX, midY + offsetY, midX + offsetX, endY, midX, endY);\n        ctx.bezierCurveTo(\n            midX - offsetX,\n            endY,\n            startX,\n            midY + offsetY,\n            startX,\n            midY\n        );\n        ctx.closePath();\n        ctx.stroke();\n    }\n}\n","import { Figure, FigureData, DrawingEventSource } from '../types';\n\nexport default class StraightLine implements Figure {\n    constructor(private _data: FigureData) {}\n    getData(): FigureData {\n        throw new Error('Method not implemented.');\n    }\n\n    get data() {\n        return this._data;\n    }\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { width, height } = ctx.canvas;\n\n        for await (const event of events) {\n            const { relativePosition } = event;\n            this._data.positions.push(relativePosition);\n            ctx.clearRect(0, 0, width, height);\n            this.render(ctx);\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        const {\n            drawOption: { color, thickness, lineCap },\n            positions,\n        } = this._data;\n        if (positions.length < 2) return;\n\n        const { width, height } = ctx.canvas;\n        const start = positions[0];\n        const end = positions[positions.length - 1];\n\n        if (lineCap) ctx.lineCap = lineCap;\n        if (color) ctx.fillStyle = color;\n\n        const startX = start.x * width;\n        const startY = start.y * height;\n        const endX = end.x * width;\n        const endY = end.y * height;\n        const dx = endX - startX;\n        const dy = endY - startY;\n        const len = Math.sqrt(dx * dx + dy * dy);\n        const sin = dy / len;\n        const cos = dx / len;\n        const a = [];\n        const controlPoints = [\n            0, \n            thickness! / 2, \n            -(9 + thickness!), \n            thickness! / 2, \n            -(12 + thickness! * 1.2), \n            (5 + thickness!)\n        ];\n\n        ctx.beginPath();\n        a.push(0, 0);\n        a.push(\n            controlPoints[0] < 0 ? len + controlPoints[0] : controlPoints[0],\n            controlPoints[1]\n        );\n        a.push(\n            Math.max(\n                controlPoints[2] < 0 ? len + controlPoints[2] : controlPoints[2],\n                0\n            ),\n            controlPoints[3]\n        );\n        a.push(\n            Math.max(\n                controlPoints[4] < 0 ? len + controlPoints[4] : controlPoints[4],\n                -3\n            ),\n            controlPoints[5]\n        );\n        a.push(Math.max(len, 12), 0);\n        a.push(\n            Math.max(\n                controlPoints[4] < 0 ? len + controlPoints[4] : controlPoints[4],\n                -3\n            ),\n            -controlPoints[5]\n        );\n        a.push(\n            Math.max(\n                controlPoints[2] < 0 ? len + controlPoints[2] : controlPoints[2],\n                0\n            ),\n            -controlPoints[3]\n        );\n        a.push(\n            controlPoints[0] < 0 ? len + controlPoints[0] : controlPoints[0],\n            -controlPoints[1]\n        );\n        a.push(0, 0);\n\n        for (let i = 0; i < a.length; i += 2) {\n            const x = a[i] * cos - a[i + 1] * sin + startX;\n            const y = a[i] * sin + a[i + 1] * cos + startY;\n            if (i === 0) ctx.moveTo(x, y);\n            else ctx.lineTo(x, y);\n        }\n\n        ctx.fill();\n    }\n}\n","import EventEmitter, { Listener } from './EventEmitter';\nimport { \n    EventMap, \n    DrawType, \n    DrawThickness, \n    DrawColor, \n    DrawOption, \n    Figure, \n    FigureData, \n    RelativePosition,\n    DrawingEvent \n} from './types';\nimport FreeLine from './Figure/FreeLine';\nimport StraightLine from './Figure/StraightLine';\nimport Rectangle from './Figure/Rectangle';\nimport Ellipse from './Figure/Ellipse';\nimport Arrow from './Figure/Arrow';\n\nexport interface PainterOptions {\n    canvas: HTMLCanvasElement;\n    width?: number;\n    height?: number;\n    drawMouse?: boolean;\n    type?: DrawType;\n    color?: DrawColor;\n    thickness?: DrawThickness;\n    lineCap?: CanvasLineCap;\n    figures?: FigureData[];\n}\n\nexport default class Painter {\n    disableMouseDrawing = () => { };\n\n    private _canvas: HTMLCanvasElement;\n    private _ctx: CanvasRenderingContext2D;\n    private _tmpCanvas: HTMLCanvasElement;\n    private _tmpCtx: CanvasRenderingContext2D;\n    private _drawOption: DrawOption;\n    private _emitter: EventEmitter;\n    private _figures: Figure[] = [];\n    private _cursor = 0;\n\n    constructor({\n        canvas,\n        width,\n        height,\n        drawMouse = true,\n        type = 'freeLine',\n        color = 'red',\n        thickness = 3,\n        lineCap = 'square',\n        figures = [],\n    }: PainterOptions) {\n        this._canvas = canvas;\n        if (!(this._ctx = canvas.getContext('2d')!)) {\n            throw new Error('2d context not supported');\n        }\n\n        if (width) canvas.width = width;\n        if (height) canvas.height = height;\n\n        this._tmpCanvas = document.createElement('canvas');\n        this._tmpCtx = this._tmpCanvas.getContext('2d')!;\n        this._drawOption = { type, color, thickness, lineCap };\n        this._emitter = new EventEmitter();\n\n        if (drawMouse) this.enableMouseDrawing();\n        for (const figure of figures) this.draw(figure);\n    }\n\n    get drawOption() {\n        return this._drawOption;\n    }\n\n    get canvas() {\n        return this._canvas;\n    }\n\n    get figures() {\n        return this._figures.map((figure) => figure.data);\n    }\n\n    get size() {\n        return { width: this._canvas.width, height: this._canvas.height };\n    }\n\n    on(name: 'drawStart' | 'drawing' | 'drawEnd' | 'figures', listener: Listener) {\n        return this._emitter.on(name, listener);\n    }\n\n    setSize({ width, height }: { width?: number; height?: number }) {\n        if (width) this._canvas.width = width;\n        if (height) this._canvas.height = height;\n    }\n\n    setOptions(drawOption: DrawOption) {\n        this._drawOption = {\n            ...this._drawOption,\n            ...drawOption,\n        };\n    }\n\n    draw({ drawOption, positions }: FigureData) {\n        const figure = createFigure(drawOption, positions);\n        this._push(figure);\n        figure.render(this._ctx);\n    }\n\n    undo() {\n        if (this._cursor > 0) {\n            this._cursor--;\n            this.redraw();\n        }\n    }\n\n    redo() {\n        if (this._cursor < this._figures.length) {\n            this._cursor++;\n            this.redraw();\n        }\n    }\n\n    clear() {\n        const { width, height } = this.size;\n        this._ctx.clearRect(0, 0, width, height);\n        this.setFigures([]);\n    }\n\n    allOff() {\n        this._emitter.allOff();\n    }\n\n    destroy() {\n        this.disableMouseDrawing();\n        this._emitter.allOff();\n    }\n\n    enableMouseDrawing() {\n        this.disableMouseDrawing();\n\n        const { canvas } = this;\n\n        let figure: Figure | null = null;\n        let resolve: (v?: DrawingEvent) => void = noop;\n\n        async function* drawingEvents() {\n            let event: DrawingEvent | undefined;\n            while (event = await new Promise<DrawingEvent | undefined>(r => resolve = r)) {\n                yield event;\n            }\n        }\n\n        const startDraw = (position: RelativePosition, event: MouseEvent | TouchEvent) => {\n            figure = createFigure(this._drawOption);\n            overlayStyle(canvas, this._tmpCanvas);\n            document.body.appendChild(this._tmpCanvas);\n            figure.drawing(this._tmpCtx, drawingEvents());\n            this._emitter.emit('drawStart', { originalEvent: event, canvas: this._canvas, relativePosition: position });\n        };\n\n        const drawing = (position: RelativePosition, event: MouseEvent | TouchEvent) => {\n            if (!figure) return;\n            const drawingEvent = { originalEvent: event, canvas: this._canvas, relativePosition: position };\n            resolve(drawingEvent);\n            this._emitter.emit('drawing', drawingEvent);\n        };\n\n        const endDraw = (position: RelativePosition, event: MouseEvent | TouchEvent) => {\n            if (!figure) return;\n            document.body.removeChild(this._tmpCanvas);\n            resolve();\n            this._ctx.drawImage(this._tmpCanvas, 0, 0);\n            this._push(figure);\n            resolve = noop;\n            figure = null;\n            this._emitter.emit('drawEnd', { originalEvent: event, canvas: this._canvas, relativePosition: position });\n        };\n\n        let lastTouch: Touch | null = null;\n        const offEvents = [\n            on(canvas, 'mousedown', (event) => {\n                const position = normalizePosition(canvas, event, this._drawOption);\n                startDraw(position, event);\n                drawing(position, event);\n            }),\n            on(canvas, 'touchstart', (event) => {\n                const position = normalizePosition(canvas, lastTouch = event.touches[0], this._drawOption);\n                startDraw(position, event);\n                drawing(position, event);\n            }),\n            on(document, 'mousemove', (event) => {\n                drawing(normalizePosition(canvas, event, this._drawOption), event);\n            }),\n            on(document, 'touchmove', (event) => {\n                drawing(normalizePosition(canvas, lastTouch = event.touches[0], this._drawOption), event);\n            }),\n            on(document, 'mouseup', (event) => {\n                endDraw(normalizePosition(canvas, event, this._drawOption), event);\n            }),\n            on(canvas, 'touchend', (event) => {\n                endDraw(normalizePosition(canvas, lastTouch!, this._drawOption), event);\n            }),\n        ];\n\n        this.disableMouseDrawing = () => offEvents.forEach(off => off());\n    }\n\n    redraw() {\n        const { width, height } = this.size;\n        this._ctx.clearRect(0, 0, width, height);\n\n        for (const figure of this._figures.slice(0, this._cursor)) {\n            figure.render(this._ctx);\n        }\n    }\n\n    setFigures(figures: FigureData[] = []) {\n        this._figures = [];\n        this._cursor = 0;\n        for (const figure of figures) this.draw(figure);\n    }\n\n    private _push(figure: Figure) {\n        (this._figures = this._figures.slice(0, this._cursor++)).push(figure);\n        this._emitter.emit('figures', this.figures);\n    }\n}\n\nfunction on<E extends HTMLElement | Document, Event extends keyof EventMap<E>>(\n    element: E,\n    name: Event,\n    callback: (event: EventMap<E>[Event]) => void\n) {\n    (element as any).addEventListener(name, callback);\n    return () => (element as any).removeEventListener(name, callback);\n}\n\nfunction createFigure(drawOption: DrawOption, positions: RelativePosition[] = []) {\n    switch (drawOption.type) {\n        case 'freeLine':\n            return new FreeLine({ drawOption, positions });\n        case 'straightLine':\n            return new StraightLine({ drawOption, positions });\n        case 'arrow':\n            return new Arrow({ drawOption, positions });\n        case 'rectangle':\n            return new Rectangle({ drawOption, positions });\n        case 'ellipse':\n            return new Ellipse({ drawOption, positions });\n        default:\n            throw new Error(`There is no figure of \"${drawOption.type}\" type.`);\n    }\n}\n\nfunction normalizePosition(\n    canvas: HTMLCanvasElement,\n    { clientX, clientY }: { clientX: number; clientY: number },\n    drawOption: DrawOption\n) {\n    const { top, left, width, height } = canvas.getBoundingClientRect();\n    const { type, thickness } = drawOption;\n    const x = clientX - left;\n    const y = clientY - top;\n\n    return type === 'freeLine' ? {\n        x: Number(x / width),\n        y: Number(y / height)\n    } : {\n        x: Number((x < 0 ? 0 + thickness! / 2 : x > width ? width - thickness! / 2 : x) / width),\n        y: Number((y < 0 ? 0 + thickness! / 2 : y > height ? height - thickness! / 2 : y) / height)\n    };\n}\n\nfunction overlayStyle(origin: HTMLCanvasElement, target: HTMLCanvasElement) {\n    const { top, left, width, height } = origin.getBoundingClientRect();\n    Object.assign(target, { width: origin.width, height: origin.height });\n    Object.assign(target.style, {\n        position: 'fixed',\n        top: top + (width - origin.width) / 2 + 'px',\n        left: left + (height - origin.height) / 2 + 'px'\n    });\n}\n\nfunction noop() { }\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_forAwaitOf","target","body","check","next","_resumeAfterNext","_reject","_resumeAfterBody","return","step","done","Promise","resolve","error","reject","_cycle","_fixup","TypeError","values","i","length","push","array","_forTo","_forOf","_earlyReturn","_AsyncGenerator","entry","_entry","_pact","_resolve","_return","_promise","_wrapReturnedValue","_wrapYieldedValue","_yield","returnValue","throw","EventEmitter","constructor","_events","emit","event","args","on","filter","fn","allOff","FreeLine","_data","data","drawing","ctx","events","drawOption","canvas","color","strokeStyle","thickness","lineWidth","lineCap","beginPath","relativePosition","positions","lineTo","width","x","height","y","stroke","moveTo","render","const","position","StraightLine","clearRect","startX","startY","Rectangle","strokeRect","Ellipse","start","end","kappa","Math","sqrt","offsetX","offsetY","endX","endY","midX","midY","bezierCurveTo","closePath","getData","Error","fillStyle","dx","dy","len","sin","cos","a","controlPoints","max","let","fill","Painter","_canvas","_ctx","getContext","_tmpCanvas","document","createElement","_tmpCtx","_drawOption","type","_emitter","drawMouse","enableMouseDrawing","figures","draw","element","name","addEventListener","removeEventListener","createFigure","Arrow","normalizePosition","getBoundingClientRect","clientX","clientY","Number","noop","_figures","map","figure","size","listener","setSize","setOptions","Object","_push","undo","_cursor","redraw","redo","clear","setFigures","destroy","disableMouseDrawing","startDraw","origin","assign","style","top","left","appendChild","test","update","stage","shouldContinue","updateValue","_resumeAfterTest","_resumeAfterUpdate","r","originalEvent","drawingEvent","endDraw","removeChild","drawImage","lastTouch","offEvents","touches","forEach","off","slice"],"mappings":"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"}