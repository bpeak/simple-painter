{"version":3,"file":"index.m.js","sources":["../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/EventEmitter.ts","../src/Figure/FreeLine.ts","../src/Figure/StraightLine.ts","../src/Figure/Rectangle.ts","../src/Figure/Ellipse.ts","../src/Painter.ts"],"sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","\nexport type Listener = (...args: any) => void;\nexport default class EventEmitter {\n    private _events: { [event: string]: Listener[] };\n\n    constructor() {\n        this._events = {};\n    }\n\n    emit(event: string, ...args: any) {\n        for (const fn of this._events[event] || []) {\n            fn(...args);\n        }\n    }\n\n    on(event: string, callback: Listener) {\n        (this._events[event] = this._events[event] || []).push(callback);\n\n        return () => (\n            this._events[event] = this._events[event].filter(fn => fn !== callback)\n        );\n    }\n\n    allOff() {\n        this._events = {};\n    }\n}","import { Figure, DrawStyle, RelativePosition, DrawingEventSource } from '../types';\n\nexport default class FreeLine implements Figure {\n    constructor(\n        private _style: DrawStyle,\n        private _positions?: RelativePosition[],\n    ) {}\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { color, thickness, lineCap } = this._style;\n        const { width, height } = ctx.canvas;\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        this._positions = [];\n        ctx.beginPath();\n\n        for await (const event of events) {\n            const { x, y } = event.relativePosition;\n\n            if (this._positions.length) {\n                ctx.lineTo(width * x, height * y);\n                ctx.stroke();\n            } else {\n                ctx.moveTo(width * x, height * y);\n            }\n\n            this._positions.push({ x, y });\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        if (!this._positions) return;\n\n        const { color, thickness, lineCap } = this._style;\n        const { width, height } = ctx.canvas;\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        ctx.beginPath();\n\n        for (const position of this._positions) {\n            ctx.lineTo(width * position.x, height * position.y);\n            ctx.stroke();\n        }\n    }\n}","import { Figure, DrawStyle, RelativePosition, DrawingEventSource } from '../types';\n\nexport default class StraightLine implements Figure {\n    constructor(\n        private _style: DrawStyle,\n        private _start?: RelativePosition,\n        private _end?: RelativePosition,\n    ) {}\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { width, height } = ctx.canvas;\n\n        for await (const event of events) {\n            const { relativePosition } = event;\n\n            if (this._start) {\n                this._end = relativePosition;\n            } else {\n                this._start = this._end = relativePosition;\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            this.render(ctx);\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        if (this._start === undefined || this._end === undefined) return;\n\n        const { color, thickness, lineCap } = this._style;\n        const { width, height } = ctx.canvas;\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        const { x: startX, y: startY } = this._start;\n        const { x, y } = this._end;\n\n        ctx.beginPath();\n        ctx.moveTo(startX * width, startY * height);\n        ctx.lineTo(x * width, y * height);\n        ctx.stroke();\n    }\n}","import { Figure, DrawStyle, RelativePosition, DrawingEventSource } from '../types';\n\nexport default class Rectangle implements Figure {\n    constructor(\n        private _style: DrawStyle,\n        private _start?: RelativePosition,\n        private _end?: RelativePosition,\n    ) {}\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { width, height } = ctx.canvas;\n\n        for await (const event of events) {\n            const { relativePosition } = event;\n\n            if (this._start) {\n                this._end = relativePosition;\n            } else {\n                this._start = this._end = relativePosition;\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            this.render(ctx);\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        if (this._start === undefined || this._end === undefined) return;\n\n        const { color, thickness, lineCap } = this._style;\n        const { width, height } = ctx.canvas;\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        const { x: startX, y: startY } = this._start;\n        const { x, y } = this._end;\n\n        ctx.strokeRect(\n            startX * width,\n            startY * height,\n            (x - startX) * width,\n            (y - startY) * height\n        );\n    }\n}","import { Figure, DrawStyle, RelativePosition, DrawingEventSource } from '../types';\n\nexport default class Ellipse implements Figure {\n    constructor(\n        private _style: DrawStyle,\n        private _start?: RelativePosition,\n        private _end?: RelativePosition,\n    ) {}\n\n    async drawing(ctx: CanvasRenderingContext2D, events: DrawingEventSource) {\n        const { width, height } = ctx.canvas;\n\n        for await (const event of events) {\n            const { relativePosition } = event;\n\n            if (this._start) {\n                this._end = relativePosition;\n            } else {\n                this._start = this._end = relativePosition;\n            }\n\n            ctx.clearRect(0, 0, width, height);\n            this.render(ctx);\n        }\n    }\n\n    render(ctx: CanvasRenderingContext2D) {\n        if (this._start === undefined || this._end === undefined) return;\n\n        const { color, thickness, lineCap } = this._style;\n        const { canvas } = ctx;\n\n        if (color) ctx.strokeStyle = color;\n        if (thickness) ctx.lineWidth = thickness;\n        if (lineCap) ctx.lineCap = lineCap;\n\n        ctx.beginPath();\n\n        const startPosition = this._start;\n        const position = this._end;\n        const startX = startPosition.x * canvas.width;\n        const startY = startPosition.y * canvas.height;\n        const x = position.x * canvas.width;\n        const y = position.y * canvas.height;\n        const width = x - startX;\n        const height = y - startY;\n        const kappa = (4 * (Math.sqrt(2) - 1)) / 3;\n        const offsetX = (width / 2) * kappa;\n        const offsetY = (height / 2) * kappa;\n        const endX = startX + width;\n        const endY = startY + height;\n        const midX = startX + width / 2;\n        const midY = startY + height / 2;\n\n        ctx.beginPath();\n        ctx.moveTo(startX, midY);\n        ctx.bezierCurveTo(startX, midY - offsetY, midX - offsetX, startY, midX, startY);\n        ctx.bezierCurveTo(midX + offsetX, startY, endX, midY - offsetY, endX, midY);\n        ctx.bezierCurveTo(endX, midY + offsetY, midX + offsetX, endY, midX, endY);\n        ctx.bezierCurveTo(midX - offsetX, endY, startX, midY + offsetY, startX, midY);\n        ctx.closePath();\n        ctx.stroke();\n    }\n}","import EventEmitter, { Listener } from './EventEmitter';\nimport { Figure, RelativePosition, DrawingEvent } from './types';\nimport FreeLine from './Figure/FreeLine';\nimport StraightLine from './Figure/StraightLine';\nimport Rectangle from './Figure/Rectangle';\nimport Ellipse from './Figure/Ellipse';\n\ntype EventMap<Element = HTMLElement> = Element extends Document ? DocumentEventMap : HTMLElementEventMap;\n\nexport type DrawThickness = number;\nexport type DrawType = 'freeLine' | 'straightLine' | 'rectangle' | 'ellipse';\nexport type DrawColor = string | CanvasGradient | CanvasPattern;\n\nexport interface DrawOption {\n    type?: DrawType;\n    color?: DrawColor;\n    thickness?: DrawThickness;\n    lineCap?: CanvasLineCap;\n}\n\nexport interface DrawFigure extends DrawOption {\n    positions: RelativePosition[];\n}\n\nexport interface PainterOptions {\n    canvas: HTMLCanvasElement;\n    width?: number;\n    height?: number;\n    drawMouse?: boolean;\n    type?: DrawType;\n    color?: DrawColor;\n    thickness?: DrawThickness;\n    lineCap?: CanvasLineCap;\n}\n\nexport default class Painter {\n    disableMouseDrawing = () => { };\n\n    private _canvas: HTMLCanvasElement;\n    private _ctx: CanvasRenderingContext2D;\n    private _tmpCanvas: HTMLCanvasElement;\n    private _tmpCtx: CanvasRenderingContext2D;\n    private _drawOption: DrawOption;\n    private _emitter: EventEmitter;\n    private _figures: Figure[] = [];\n    private _cursor = 0;\n\n    constructor({\n        canvas, \n        width,\n        height,\n        drawMouse = true,\n        type = 'freeLine',\n        color = 'red',\n        thickness = 3,\n        lineCap = 'square'\n    }: PainterOptions) {\n        this._canvas = canvas;\n        if (!(this._ctx = canvas.getContext('2d')!)) {\n            throw new Error('2d context not supported');\n        }\n\n        if (width) canvas.width = width;\n        if (height) canvas.height = height;\n\n        this._tmpCanvas = document.createElement('canvas');\n        this._tmpCtx = this._tmpCanvas.getContext('2d')!;\n        this._drawOption = { type, color, thickness, lineCap };\n        this._emitter = new EventEmitter();\n\n        if (drawMouse) this.enableMouseDrawing();\n    }\n\n    get canvas() {\n        return this._canvas;\n    }\n\n    get size() {\n        return { width: this._canvas.width, height: this._canvas.height };\n    }\n\n    on(name: 'drawStart' | 'drawing' | 'drawEnd', listener: Listener) {\n        return this._emitter.on(name, listener);\n    }\n\n    setSize({ width, height }: { width?: number; height?: number }) {\n        if (width) this._canvas.width = width;\n        if (height) this._canvas.height = height;\n    }\n\n    setOptions(drawOption: DrawOption) {\n        this._drawOption = {\n            ...this._drawOption,\n            ...drawOption,\n        };\n    }\n\n    draw(figure: Figure) {\n        this._push(figure);\n        figure.render(this._ctx);\n    }\n\n    undo() {\n        if (this._cursor > 0) {\n            this._cursor--;\n            this.redraw();\n        }\n    }\n\n    redo() {\n        if (this._cursor < this._figures.length) {\n            this._cursor++;\n            this.redraw();\n        }\n    }\n\n    clear() {\n        const { width, height } = this.size;\n        this._ctx.clearRect(0, 0, width, height);\n    }\n\n    destroy() {\n        this.disableMouseDrawing();\n        this._emitter.allOff();\n    }\n\n    enableMouseDrawing() {\n        this.disableMouseDrawing();\n\n        const { canvas } = this;\n\n        let drawingFigure: Figure | null = null;\n        let resolve: (v?: DrawingEvent) => void = noop;\n\n        async function* drawingEvents() {\n            let event: DrawingEvent | undefined;\n            while (event = await new Promise<DrawingEvent | undefined>(r => resolve = r)) {\n                yield event;\n            }\n        }\n\n        const startDraw = (position: RelativePosition, event: MouseEvent | TouchEvent) => {\n            switch (this._drawOption.type) {\n            case 'freeLine':\n                drawingFigure = new FreeLine(this._drawOption);\n                break;\n            case 'straightLine':\n                drawingFigure = new StraightLine(this._drawOption);\n                break;\n            case 'rectangle':\n                drawingFigure = new Rectangle(this._drawOption);\n                break;\n            case 'ellipse':\n                drawingFigure = new Ellipse(this._drawOption);\n                break;\n            default:\n                throw new Error(`There is no figure of \"${this._drawOption.type}\" type.`);\n            }\n\n            overlayStyle(canvas, this._tmpCanvas);\n            document.body.appendChild(this._tmpCanvas);\n\n            drawingFigure.drawing(this._tmpCtx, drawingEvents());\n            this._emitter.emit('drawStart', { originalEvent: event, canvas: this._canvas, relativePosition: position });\n        };\n\n        const drawing = (position: RelativePosition, event: MouseEvent | TouchEvent) => {\n            if (!drawingFigure) return;\n            const drawingEvent = { originalEvent: event, canvas: this._canvas, relativePosition: position };\n            resolve(drawingEvent);\n            this._emitter.emit('drawing', drawingEvent);\n        };\n\n        const endDraw = (position: RelativePosition, event: MouseEvent | TouchEvent) => {\n            if (!drawingFigure) return;\n            document.body.removeChild(this._tmpCanvas);\n            resolve();\n            this._ctx.drawImage(this._tmpCanvas, 0, 0);\n            this._push(drawingFigure);\n            resolve = noop;\n            drawingFigure = null;\n            this._emitter.emit('drawEnd', { originalEvent: event, canvas: this._canvas, relativePosition: position });\n        };\n\n        let lastTouch: Touch | null = null;\n        const offEvents = [\n            on(canvas, 'mousedown', (event) => {\n                const position = normalizePosition(canvas, event);\n                startDraw(position, event);\n                drawing(position, event);\n            }),\n            on(document, 'mousemove', (event) => {\n                const position = normalizePosition(canvas, event);\n                drawing(position, event);\n            }),\n            on(document, 'mouseup', (event) => {\n                const position = normalizePosition(canvas, event);\n                endDraw(position, event);\n            }),\n            on(canvas, 'touchstart', (event) => {\n                const position = normalizePosition(canvas, lastTouch = event.touches[0]);\n                startDraw(position, event);\n                drawing(position, event);\n            }),\n            on(document, 'touchmove', (event) => {\n                const position = normalizePosition(canvas, lastTouch = event.touches[0]);\n                drawing(position, event);\n            }),\n            on(document, 'touchend', (event) => {\n                const position = normalizePosition(canvas, lastTouch!);\n                endDraw(position, event);\n            }),\n        ];\n\n        this.disableMouseDrawing = () => offEvents.forEach(off => off());\n    }\n\n    redraw() {\n        this.clear();\n        for (const figure of this._figures.slice(0, this._cursor)) {\n            figure.render(this._ctx);\n        }\n    }\n\n    private _push(figure: Figure) {\n        (this._figures = this._figures.slice(0, this._cursor++)).push(figure);\n    }\n}\n\nfunction on<E extends HTMLElement | Document, Event extends keyof EventMap<E>>(\n    element: E,\n    name: Event,\n    callback: (event: EventMap<E>[Event]) => void\n) {\n    (element as any).addEventListener(name, callback);\n    return () => (element as any).removeEventListener(name, callback);\n}\n\nfunction normalizePosition(\n    canvas: HTMLCanvasElement,\n    { clientX, clientY }: { clientX: number; clientY: number }\n) {\n    const { top, left, width, height } = canvas.getBoundingClientRect();\n    return {\n        x: Number((clientX - left) / width),\n        y: Number((clientY - top) / height)\n    };\n}\n\nfunction overlayStyle(origin: HTMLCanvasElement, target: HTMLCanvasElement) {\n    const { top, left, width, height } = origin.getBoundingClientRect();\n    Object.assign(target, { width: origin.width, height: origin.height });\n    Object.assign(target.style, {\n        position: 'fixed',\n        top: top + (width - origin.width) / 2 + 'px',\n        left: left + (height - origin.height) / 2 + 'px'\n    });\n}\n\nfunction noop() { }\n"],"names":["_Pact","prototype","then","onFulfilled","onRejected","result","state","this","s","callback","_settle","v","e","o","_this","value","pact","bind","observer","_isSettledPact","thenable","_iteratorSymbol","Symbol","iterator","_asyncIteratorSymbol","asyncIterator","_forAwaitOf","target","body","check","next","_resumeAfterNext","_reject","_resumeAfterBody","return","step","done","Promise","resolve","error","reject","_cycle","_fixup","TypeError","values","i","length","push","array","_forTo","_forOf","_earlyReturn","_AsyncGenerator","entry","_entry","_pact","_resolve","_return","_promise","_wrapReturnedValue","_wrapYieldedValue","_yield","returnValue","throw","EventEmitter","constructor","_events","emit","event","args","on","filter","fn","allOff","FreeLine","_style","_positions","drawing","ctx","events","canvas","color","strokeStyle","thickness","lineWidth","lineCap","beginPath","relativePosition","lineTo","width","x","height","y","stroke","moveTo","render","const","position","StraightLine","_start","_end","clearRect","undefined","startX","startY","Rectangle","strokeRect","Ellipse","startPosition","kappa","Math","sqrt","offsetX","offsetY","endX","endY","midX","midY","bezierCurveTo","closePath","Painter","_canvas","_ctx","getContext","Error","_tmpCanvas","document","createElement","_tmpCtx","_drawOption","type","_emitter","drawMouse","enableMouseDrawing","element","name","addEventListener","removeEventListener","normalizePosition","getBoundingClientRect","Number","clientX","clientY","top","noop","size","listener","setSize","setOptions","drawOption","Object","draw","figure","_push","undo","_cursor","redraw","redo","_figures","clear","destroy","disableMouseDrawing","drawingFigure","startDraw","origin","assign","style","left","appendChild","test","update","stage","shouldContinue","updateValue","_resumeAfterTest","_resumeAfterUpdate","r","originalEvent","drawingEvent","endDraw","removeChild","drawImage","lastTouch","offEvents","touches","forEach","off","slice"],"mappings":"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"}